import 'dart:convert';
import 'dart:typed_data';
import 'dart:math';
import 'package:cryptography/cryptography.dart';

class EncryptionService {
  /* 
    https://pub.dev/documentation/cryptography/latest/cryptography/AesGcm-class.html
    https://en.wikipedia.org/wiki/Galois/Counter_Mode
    Creating a AES-GCM instance for 256-bit keys (AES-GCM(Advanced Encryption Standard in Galois Counter Mode) is a encryption mode for symmectric-key cryptographic block ciphers).
    AES-GCM provides both encryption and authentication.  
  */
  final AesGcm aesGcm = AesGcm.with256bits();

  /*  
    https://api.dart.dev/dart-typed_data/Uint8List-class.html
    Uint8List returns a list of unsigned 8-bit integers, we need to use that because Argon2 doesn't work on string or numbers but only on raw bytes.
    This function generates a random salt of the specified length (default(recommended) = 16 bytes(128 bits)).
    https://datatracker.ietf.org/doc/html/rfc9106#section-3
  */
  Uint8List generateSalt() {
    /* 
      Generates 16 random bytes (or specified length) using the secure random number generator.
      The `List.generate` function creates a list of the specified length, where each element is generated by the provided function.
      The `random.nextInt(256)` generates a random integer between 0 and 255 (inclusive), which corresponds to a byte value.
      The `Uint8List.fromList` creates a Uint8List from the regularly generated list of integers.
    */
    return Uint8List.fromList(
      List.generate(16, (_) => Random.secure().nextInt(256)),
    );
  }

  /*
    https://pub.dev/documentation/cryptography/latest/cryptography/Argon2id-class.html
    https://pub.dev/documentation/cryptography/latest/cryptography/Argon2id/deriveKey.html
    This function derives a secret key from the master password and salt using the Argon2id algorithm.
    Argon2id is a memory-hard function designed to resist GPU-based attacks, making it suitable for securely hashing passwords.
    The derived key will be used for encryption and decryption of data.

    Future<SecretKey> indicates that this function is asynchronous and will return a SecretKey in the future.
  */
  Future<SecretKey> deriveKey(String masterPassword, Uint8List salt) async {
    /*
      Argon2id is a variant of the Argon2 password hashing algorithm that is designed to be resistant to side-channel attacks.
      It uses a combination of memory-hard functions and parallelism to derive a key from a password and salt.
      The parameters used here are:
      https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#password-hashing-algorithms
      (Values are suggestions from OWASP in the cryptography-package documentation)
      - parallelism: Number of threads to use for hashing (1 in this case).
      - memory: Amount of memory to use for hashing (19000 KB (19MB) in this case).
      - iterations: Number of iterations to perform (2 in this case).
      - hashLength: Length of the derived key (32 bytes in this case).
      These parameters can be adjusted based on the security requirements and performance considerations.
    */
    final argon2id = Argon2id(
      parallelism: 1,
      memory: 19000,
      iterations: 2,
      hashLength: 32,
    );

    /*
      https://pub.dev/documentation/cryptography/latest/cryptography/KdfAlgorithm/deriveKeyFromPassword.html
      deriveKeyFromPassword is a method that derives a key from the provided password and salt.
      await is used to wait for the asynchronous operation to complete (just like in JS).
    */
    final secretKey = await argon2id.deriveKeyFromPassword(
      password: masterPassword,
      nonce: salt,
    );

    return secretKey;
  }

  /*
    https://pub.dev/documentation/cryptography/latest/cryptography/Cipher/encrypt.html
    This function encrypts a plain text password using AES-GCM with the provided secret key.
    It generates a nonce (number used once), which is a random sequence of bytes used to encrypt passwords.
    The nonce must be unqiue for eacht encryption operation to ensure security with the same secret key.
    The encrypted data is returned as a map containing the nonce, cipher text, and MAC (Message Authentication Code).
  */
  Future<Map<String, dynamic>> encryptPassword(
    String plainTextPassword,
    SecretKey secretKey,
  ) async {
    /*
      Generates a nonce (number used once) for the encryption operation.
      The nonce should be unique for each encryption operation to ensure security.
      Here, we generate a nonce of 12 bytes (96 bits) as recommended for AES-GCM
    */
    final nonce = Uint8List.fromList(
      List.generate(12, (_) => Random.secure().nextInt(256)),
    );

    final secretBox = await aesGcm.encrypt(
      utf8.encode(
        plainTextPassword,
      ), //converts the plain text password to bytes
      secretKey: secretKey, //the secret key derived from the master password
      nonce: nonce, //the nonce generated for this encryption operation
    );

    /*
      The secretBox contains the encrypted data, nonce, and MAC (Message Authentication Code).
      The nonce is needed for decryption.
      The MAC is used to verify the integrity of the encrypted data.
      We encode everything to base64 so we can store the data in files.
    */
    return {
      'nonce': base64.encode(secretBox.nonce),
      'cipherText': base64.encode(secretBox.cipherText),
      'mac': base64.encode(secretBox.mac.bytes),
    };
  }

  /* 
    https://pub.dev/documentation/cryptography/latest/cryptography/Cipher/decrypt.html
    This function decrypts the SecretBox(encrypted password) using AES-GCM.
    It takes the encrypted data (nonce, cipher text, and MAC from the file) and decrypts it using the Secret Key used for encryption.
  */
  Future<String> decryptPassword(
    Map<String, dynamic> encryptedData,
    SecretKey secretKey,
  ) async {
    /*
      We decode the base64 encoded values to get the original raw bytes.
      The Mac() is used to reconstruct the MAC from bytes
    */
    final nonce = base64.decode(encryptedData['nonce']);
    final cipherText = base64.decode(encryptedData['cipherText']);
    final mac = Mac(base64.decode(encryptedData['mac']));

    /* 
      The SecretBox is a container for the encrypted data, nonce, and MAC.
      It is used to hold the encrypted password and its associated metadata.
      The SecretBox is then passed to the decrypt method of the AES-GCM instance to decrypt the password.
    */
    final secretBox = SecretBox(cipherText, nonce: nonce, mac: mac);

    /*
      Decrypts the secretBox using the AES-GCM instance and the secret key.
      The decrypted data is returned as a list of bytes.
      The utf8.decode() converts the decrypted bytes back to a string.
    */
    final clearText = await aesGcm.decrypt(secretBox, secretKey: secretKey);

    return utf8.decode(clearText);
  }
}
